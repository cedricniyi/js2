---
title: "Module 7 : SPA & s√©curisation"
description: "S√©curisation de SPA √† l'aide d'authentification & autorisation JWT"
---

# Module 7 : SPA & s√©curisation
Ce module vous offre principalement la s√©curisation de SPA √† l'aide 
d'authentification & autorisation JWT.

Dans un premier temps, nous allons voir comment s√©curiser les acc√®s aux op√©rations d'une API.  
Puis, nous allons voir comment int√©grer ces API s√©curis√©es au sein d'IHM.

En r√©sum√©, on souhaite s√©curiser l'acc√®s 
aux utilisateurs, de fa√ßon moderne, √† certaines op√©rations sur des ressources.

<br/>

Voici les sujets trait√©s :
- 



# <a id="a"></a>a) Authentification s√©curis√©e et autorisation d'acc√®s aux op√©rations d'une RESTful API via JWT

## <a id="a1"></a>a.1) Authentification et autorisation : g√©n√©ralit√©s

### a.1.1) Authentification, c'est quoi ?
L'authentification, c'est le processus de v√©rifier qui est l'utilisateur d'une application.

Pour authentifier un utilisateur, on va g√©n√©ralement passer via un formulaire de connexion, lui demandant un username et un password.

### a.1.2) Autorisation, c'est quoi ?
L'autorisation, c'est le processus de v√©rifier ce √† quoi un utilisateur √† acc√®s.

Une API va autoriser les acc√®s √† certaines op√©rations en fonction des privil√®ges associ√©s aux utilisateurs. Il y aura des op√©rations qui seront autoris√©es : 
- pour tous les utilisateurs, tant anonymes qu'authentifi√©s ; imaginez par exemple les op√©rations de lectures de produits sur un site "vitrine". Il ne faut pas devoir cr√©er de compte utilisateur pour pouvoir afficher les produits du site.
- pour tous les utilisateurs authentifi√©s, peu importe leurs privil√®ges ; imaginez le fait de pouvoir poster des messages dans un forum ; il faut avoir un compte pour pouvoir le faire, mais il ne faut pas de privil√®ges sp√©cifiques (pas besoin d'√™tre admin).
- pour seulement un ou plusieurs utilisateur(s) authentifi√©(s) ayant les privil√®ges requis ; imaginez une op√©ration de lecture de tous les profils des utilisateurs d'une banque ; il faut avoir un compte admin de la banque pour pouvoir le faire. Ca serait catastrophique si n'importe quel utilisateur authentifi√© pourrait acc√©der aux profils de tous les utilisateurs !

### a.1.3) Diff√©rents moyens d'authentification
Il existe de nombreux m√©canismes d'authentification.

Traditionnellement, ou anciennement, nous avons l'authentification qui est support√©e √† l'aide de cookies. L'utilisateur envoie via un formulaire son username et password, le serveur v√©rifie ceux-ci et cr√©e un id de session et le renvoie √† l'utilisateur via un cookie.  
Apr√®s l'authentification, √† chaque requ√™te du client sur ce serveur, le cookie est envoy√©, et le serveur, qui a sauvegard√© la session, va retrouver la session sur base de l'id de session pr√©sent dans le cookie et va autoriser ou non l'acc√®s √† l'op√©ration demand√©e par le client.  
C'est ce qu'on appelle une authentification **stateful**.

Un m√©canisme d'authenfication **stateful** indique que le serveur est responsable de sauvegarder les donn√©es de session des utilisateurs. 

On parle de **session** d'un utilisateur commme √©tant toute la dur√©e o√π le client s'authentifie √† l'application web jusqu'√† ce qu'il quitte cette application, lorsqu'il ferme son browser.

De mani√®re plus moderne, nous avons des m√©canismes d'authentification qui sont dits **stateless**. Dans ce genre de m√©canisme, c'est le client qui doit sauvegarder les donn√©es de session, et donc le browser. L'authentification √† l'aide de **tokens** devient tr√®s populaires.  
Il existe diff√©rents moyen de l'impl√©menter. Dans le cadre de ce cours, nous focuserons sur la fa√ßon la plus habituel, les **JSON Web Token**, ou **JWT**.

Il existe d'autres m√©chanismes tr√®s modernes qui utilisent des tokens, mis en place par des tiers : **OAuth**, **OpenId**... Ces m√©chanismes sont mis en place par Microsoft, Google, Facebook... Nous ne les verrons pas dans le cadre de cours. N√©anmoins, √† la fin de ce cours, vous devriez √™tre aptes √† pouvoir les utiliser, sous r√©serve de bien lire la documentation.

### a.1.4) Stateful VS stateless authentication 
Quels sont les avantages & inconv√©nients d'une authentification stateful ? et d'une authentification stateless ?

#### Authentification stateful
**Inconv√©nients** :
- La session utilise de la m√©moire pour chaque utilisateur.
- Le backend n'a aucune mani√®re de d√©terminer si le frontend s'est d√©connect√© du site ou non : gestion de l'expiration d'une session plus compliqu√©e, notamment si le frontend revient apr√®s une longue dur√©e.
- Toutes les sessions sont perdues en cas de red√©marrage du serveur (r√©authentification).
- Load balancing compliqu√© ; en effet, si un client fait une requ√™te, pendant toute la dur√©e de la session, s'il y a plusieurs serveurs qui peuvent y r√©pondre, comment est g√©r√© la session de ce client, par quel(s) serveur(s), comment se partagent-ils les donn√©es de session ? Ou est-ce que √ßa doit toujours √™tre le m√™me serveur qui r√©pond au m√™me client ?

**Avantages** :
- Peu gourmand en ressource et tr√®s rapide ; en effet, une fois qu'une session est en place, il est tr√®s rapide de v√©rifier que le cookie contient le bon id de session.

#### Authentification stateless
**Inconv√©nients** : 
Comme le serveur ne retient plus l'utilisateur en m√©moire, il doit utiliser de la cryptographie pour cr√©er et valider les token ; c'est donc consommateur en ressource.

**Avantages** : 
- Pas de session √† g√©rer, m√™me apr√®s red√©marrage du serveur, il n'y a pas de r√©authentification n√©cessaire.
- Evolutif, utilisation facile de plusieurs serveurs si du load balancing est n√©cessaire ; en effet, comme chaque requ√™te du client contient toutes les infos pour se faire autoriser, peu importe quel est le serveur qui va prendre en charge la requ√™te.

Notons que la "scalability" horizontale, la possibilit√© de permettre √† une application d'augmenter sa capacit√© de r√©pondre √† une charge grandissante simplement en ajoutant des machines, est quelque chose de tr√®s important √† notre √©poque.  
Certaines applications web ont des centaines de millions d'utilisateurs ; pour celles-ci, on ne peut pas compter sur la "scalability" veriticale, c'est-√†-dire le fait d'augmenter les ressources d'une machine, en augmentant sa RAM, son processeur, son espace de stockage...

D√®s lors, dans le cadre de ce cours, nous allons pr√©f√©rer les applications web qui peuvent tourner sur des serveurs **stateless**.

## <a id="a2"></a>a.2) Token JWT

Les JSON Web token, ou JWT, est un standard internet permettant l'√©change s√©curis√© de tokens entre plusieurs parties.

Un JWT contient trois parties et ressemblera √† qqch du style car ses 3 parties, une fois pr√™tes, sont encod√©es en base64 :
**`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.`**.  
**`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.`**.    
**`SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`**.

Voici les caract√©ristiques de ses trois parties :
- l'**ent√™te** (ou header) : un objet JSON identifiant le type de token (JWT) et l'algorithme utilis√© pour g√©n√©rer la signature du token (HS256), un algorithme de hachage. 
- le **payload** : un objet JSON permettant de sp√©cifier le **claim** ; ce sont des param√®tres optionnels pr√©cisant les affirmations associ√©es au token, comme la date d'expiration du token, son cr√©ateur, le fait que l'utilisateur est admin... g√©n√©ralement, on y met pas trop d'info, principalement l'identifiant de l'utilisateur ; si l'API a besoin de plus d'info concernant l'utilisateur, elle ira g√©n√©ralement les chercher dans son support de donn√©es.
- la **signature** : c'est une signature num√©rique construite √† partir d'un secret priv√© ou d'une cl√© publique/priv√©e, via l'algorithme pr√©cis√© dans la signature.

üí≠ C'est bien joli tout √ßa, mais comment √ßa permet de s√©curiser la session d'un utilisateur ?  
G√©n√©ralement, l'API, et elle uniquement, connait le secret priv√©. Elle va donc cr√©er le token d'un utilisateur authentifi√©, en y ajoutant le claim (ou les affirmations) qu'elle juge utile.  
Lorsque le client re√ßoit son token, il va le sauvegarder dans son browser.  
Pour chaque requ√™te o√π il devra se faire autoriser par l'API, le client enverra son token au sein d'un header de la requ√™te.  
L'API utilisera le secret priv√©, connu d'elle-m√™me uniquement, pour v√©rifier la signature du token. Si tout est OK, c'est que l'utilisateur est bien authentifi√© et que son claim est OK.

Imaginez maintenant qu'un hackeur tente de modifier le token, pour modifier le claim, notamment en changeant l'id de l'utilisateur pr√©sent dans le payload du token.
Et bien la signature ne correspondra plus √† ce token l√† ! L'API le d√©tectera.  
Pour que le hackeur r√©ussisse son acte malicieux, il est oblig√© de conna√Ætre le secret priv√© qui ne doit √™tre connu que de l'API.  
Seulement dans le cas o√π le hackeur ou la hackeuse conna√Æt le secret priv√©, pourra-t-il ou pourra-t-elle g√©n√©rer un nouveau token qui sera valid√© par l'API. Pas √©vident...

Ainsi, on peut imaginer un token comme une enveloppe s√©curis√© par un cadena tr√®s sp√©cial : ce cadenas, qui est mis sur l'enveloppe contenant, par exemple, l'identifiant d'un utilisateur, est ferm√© par la cl√© üîë que seulement conna√Æt l'API.
Si quelqu'un touche √† l'enveloppe, le cadena ne s'ouvrira plus avec la üîë de l'API : la tentative de hackage sera d√©tect√©e ! 
Si quelqu'un tente de cr√©er une enveloppe s√©curis√©, il le fera avec une autre cl√©, **üóù** par exemple, car il ne conna√Æt pas üîë. L'API, tentant d'ouvrir l'enveloppe s√©curis√©e √† l'aide de üîë, elle ne s'ouvrira pas : la tentative de hackage sera d√©tect√©e ! 

üí≠ Est-ce que cette m√©thaphore d'enveloppe s√©curis√©e vous parle ?
Attention que dans la r√©alit√©, le payload classique d'un token sera d√©codable, que l'on connaisse ou pas le secret priv√©. Il est encod√© en base64 ! Ne mettez donc jamais de secrets dans le payload d'un token !  
Si vraiment un jour vous devez mettre un secret dans un payload, bien que d√©conseill√©, vous pourriez toujours le faire en cryptant le payload.

üëç Le m√©canisme de token assure que l'on aie une tr√®s haute probabilit√© de d√©tecter les alt√©rations faites sur les tokens, les tentatives de forgeage gr√¢ce √† la signature de ceux-ci.  
‚ö° Par contre, si nous laissons tra√Æner des informations dans le payload d'un token comme un password d'un utilisateur et son username, alors l√†, c'est juste un beau cadeau pour les hackeurs, il n'auront qu'√† utiliser le formulaire de connexion et prendre possession de notre identit√© üò®.

Il existe un site fort int√©ressant qui montre la structure d'un token et qui permet de les d√©coder : [jwt.io](https://jwt.io/) [[R.63]](/references/#r63). Nous l'utiliserons plus tard pour d√©coder les tokens g√©n√©r√©s par nos RESTful API.

## <a id="a2"></a>a.2) M√©canisme d'authentification stateless via JWT
### a.2.1) Introduction

Via un exemple concret associ√© √† notre RESTful API qui g√®re les ressources de type "pizzas", voici comment nous allons mettre en place un processus d'authentification et d'autorisation JWT.

### a.2.2) M√©canisme d'authentification et cr√©ation du token

Toujours √† l'aide d'Express, nous allons cr√©er un router **auths** qui mettra √† disposition les op√©rations de login et de register. Un model **users** s'occupera de cr√©er les utilisateur, de v√©rifier leurs credentials ainsi que de cr√©er des token.

<ScrollableImage name="login.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une RESTful API pour s'authentifier et obtenir un JWT</figcaption>

Ce que l'on voit dans l'image ci-dessus : 
- si le mod√®le consid√®re que l'utilisateur est authentifiable, que ses credentials sont OK, alors il va utiliser une librairie **jwt** et la m√©thode **sign** pour cr√©er un token. 
- le token est envoy√© dans le body de la r√©ponse √† l'utilisateur. 

Ce que l'on ne voit pas dans l'image ci-dessus :
- c'est le job du client de sauvegarder le token. Si l'application cliente est un browser, alors celui-ci pourra √™tre sauvegard√© dans le web storage du browser.
- l'application cliente peut √™tre faite avec n'importe quelle technologie. Par exemple, nous pourrons utiliser REST Client pour faire une requ√™te √† l'API...

Dans notre RESTful API, nous avons d√©cid√© que lorsqu'un client s'enregistre, qu'il fait appel √† l'op√©ration **register** pour cr√©er un compte, l'API consid√®re automatiquement que cet utilisateur est authentifi√©. Tout comme la m√©thode **login**, la m√©thode **register** cr√©era et renverra un token JWT √† l'utilisateur.

NB : Il est possible d'envisager un workflow diff√©rent : apr√®s le **register**, l'application demanderait √† l'utilisateur un **login**, **register** ne renvoyant jamais de token √† l'utilisateur.

### a.2.3) M√©canisme d'autorisaton et v√©rification du token
Suite au **register** ou au **login** de l'utilisateur, tel qu'il a √©t√© d√©cid√© pour notre future RESTful API, celui-ci a re√ßu un token et l'a sauvegard√© au niveau du web storage de son browser. 

Lorsqu'une application client souhaite cr√©er une pizza, on souhaite autoriser cette op√©ration qu'√† l'administrateur du site g√©rant la pizz√©ria.  
Nous d√©cidons donc pour l'op√©ration de cr√©ation de pizza que l'utilisateur doit non seulement √™tre authentifi√©, mais qu'en plus, il doit √™tre l'admin.

Pour que l'application client qui fait la requ√™te √† l'API puisse s'autoriser, elle doit ajouter un **authorization header** √† sa requ√™te contenant comme valeur le token re√ßu lors du **login** ou du **register** :

<ScrollableImage name="authorizeOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation valide</figcaption>

Le router de "pizzas", avant m√™me de passer la requ√™te √† la route **POST /pizzas**, va lancer la fonction middleware d'autorisation nomm√©e **authorize**. **authorize** va s'occuper de v√©rifier le token envoy√© par le client dans un header √† l'aide de la m√©thode **verifiy** de la librairie **jwt**.  


üí≠ Si le token est valide, est-ce que √ßa signifie que l'utilisateur est bien authentifi√© ?
H√© bien non, car imaginez qu'entre le moment o√π l'utilisateur se soit logu√©, il ait √©t√© supprim√© de l'application par un admin... dans ce cas-ci, on ne veut pas l'autoriser √† ajouter une pizza au menu de la pizzeria ! Il n'est p-e m√™me plus un employ√©, il souhaite p-e √©crire du contenu malicieux üò®

Donc si le token est valide, **authorize** fera appel au mod√®le de **users** pour v√©rifier que l'utilisateur existe bien dans le support de donn√©es (fichiers JSON, base de donn√©es ou autres) et pour obtenir toutes les infos sur cet utilisateur. Si l'utilisateur existe, alors cela signifie que l'utilisateur est bien authentifi√©. La fonction middleware **authorize** va passer la main √† une autre fonction middleware pour v√©rifier que l'utilisateur est bien l'admin.

üí≠ Comment est-ce que **authorize** peut faire appel au mod√®le pour v√©rifier que l'utilisateur existe bien ? Est-ce que cela signifie que le token doit contenir tout un tas de donn√©es sur l'utilisateur ? 
üëç En r√®gle g√©n√©rale, on va juste mettre un identifiant de l'utilisateur dans ce qu'on appelle le **payload** du token. C'est ensuite l'API, suite au d√©codage de l'identifiant de l'utilisateur, qui fera appel au support de donn√©es pour retrouver toutes les donn√©es de l'utilisateur.

NB : notez que l'on pourrait aussi laisser la fonction **createOnePizza** s'occuper de v√©rifier que l'utilisateur demandant la cr√©ation de la pizza soit bien l'admin. Ici, comme il s'agit de v√©rifier que le contrat de l'API soit respect√©, c'est-√†-dire que l'utilisateur soit bien authentifi√© & admin, alors on pr√©f√®re r√©aliser cette action en dehors du mod√®le, car dans nos choix architecturaux au niveau de nos RESTful API, nous avons d√©cid√© que ce n'est pas le mod√®le qui s'occupe de pr√©senter les donn√©es aux clients.

La fonction middleware **isAdmin** associ√© au token va v√©rifier que l'utilisateur est bien l'admin. Si c'est OK, elle passera la main √† la fonction middleware qui g√®re la route **POST /pizzas** au sein du router de pizzas en faisant l'appel √† la fonction **next**.

Maintenant que le client a les bons privil√®ges, l'op√©ration de cr√©ation de la pizza peut donc √™tre autoris√©e. L'op√©ration de **createOnePizza** du mod√®le renverra la nouvelle pizza au router qui s'occupera de pr√©senter la nouvelle pizza au client, au format JSON.

Par contre, voici le workflow si le token n'est pas valide :

<ScrollableImage name="authorizeNOK.png" minWidth="879px" maxWidth="879x" />
<figcaption>Appel √† une op√©ration d'une RESTful API n√©cessitant une autorisation JWT : autorisation invalide</figcaption>

Dans ce cas l√†, **authorize** ne passe pas la main √† **isAdmin** ou m√™me √† la fonction middleware qui g√®re la route **POST /pizzas**.  
**authorize** renvoie directement un code d'erreur **401 Unauthorized** au client. 

Vous pourriez aussi imaginer le workflow o√π le client envoie un token valide, mais l'utilisateur associ√© n'est pas admin. Dans ce cas-ci, **authorize** ferait appel √† **isAdmin**, mais **isAdmin** renverrait directement un code d'erreur **403 Forbidden** au client.  
En effet, l'API indiquerait ainsi qu'elle aurait v√©rifi√© que l'utilisateur est bien authentifi√©, mais que celui ne poss√®de pas les privil√®ges suffisant pour acc√©der √† l'op√©ration demand√©e.

