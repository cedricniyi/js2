---
title: "Module 4 : Service web & clients"
description: "Cr√©ation de services web, de RESTful API & requ√™tes clientes"
---

# Module 4 : Service web & clients
Ce module vous offre principalement la cr√©ation de services web et la mise en place de 
requ√™tes clientes pour tester des RESTful API.

Voici les sujets trait√©s :
- a) [Introduction au backend](#a)
- b) [Introduction √† Node.js](#b)
  - b.1) [Introduction](#b1)
  - b.2) [Ou mettre du code Node.js ?](#b2)
  - b.3) [Les modules CommonJS](#b3)
  - b.4) [Introduction aux packages](#b4)
- c) [Introduction √† Express](#c)
  - c.1) [Introduction](#c1)
  - c.2) [Cr√©er une application Express "from scratch"](#c2)
  - c.3) [Cr√©er une application Express via un g√©n√©rateur](#c3)
- d) [Introduction aux RESTful API](#d)
  - d.1) [Introduction](#d1)
  - d.2) [Conventions REST](#d2)
- e) [RESTful API via Express](#e)
  - e.1) [Intro](#e1)
  - e.2) [](#e2)
  - e.3) [](#e3)

# <a id="a"></a>a) Introduction au backend
## a.1) Frontend, backend, c'est quoi ?
Un **frontend**, c'est une application :
- qui s'ex√©cute c√¥t√© client, une IHM, qu'on pourrait aussi appeler UI ;
- qui est en direct interaction avc l'utilisateur ;
- impl√©ment√©, dans ce cours-ci, en HTML / CSS / JS.

Un **backend**, c'est une application :
- qui s'ex√©cute c√¥t√© serveur ; 
- qui n'offre pas d'interaction directe avec l'utilisateur ;
- qui parfois met √† disposition le **frontend** ;
- qui parfois offre des op√©rations sur des donn√©es.

## a.2) R√¥les principaux du backend
### a.2.1) Fourniture du frontend
Un des r√¥les du backend est de fournir le frontend :
- **via un serveur de fichiers statiques** ; c'est la mise √† disposition des assets : fichiers HTML,
CSS, JS, images...
- **via la g√©n√©ration dynamique de pages HTML** ; c'est ce qui se passe quand le backend 
fait du Server Side Rendering (SSR), g√©n√©ralement dans le cadre de Multi Page Applications.  

Dans le cadre de ce cours, nous ne ferons pas de g√©n√©ration dynamique d'HTML c√¥t√© serveur (ou SSR).  
Par contre, nous avons d√©j√† vu :
- comment faire de la g√©n√©ration dynamique d'HTML c√¥t√© client (ou 
Client Side Rendering = CSR).
- mettre √† disposition notre frontend, notre IHM, √† l'aide d'un serveur de fichiers statiques : 
c'est ce que notamment fait le serveur de d√©veloppement de Webpack, il me √† disposition les assets 
permettant au browser d'ex√©cuter l'application web.

### a.2.2) Fourniture d'op√©rations sur des ressources
Un autre r√¥le important du backend est de mettre √† disposition des op√©rations sur des ressources,
c'est ce qu'on appelle les services web ou web API.

Il existe diff√©rents types de technologies et architectures web permettant d'impl√©menter 
des web services, notamment :
- **RESTful API** ; c'est l'architecture qui actuellement est la plus utilis√©e et qui sera apprise dans 
le cadre de ce cours.
- **GraphQL API** ; c'est une technologie r√©cente qui permet de tr√®s rapidement cr√©er des requ√™tes 
sur des ressources et qui a √©t√© cr√©√©e par Facebook ; nous ne verrons pas cette technologie dans 
le cadre de ce cours.
- **SOAP API** ; c'est une fa√ßon ancienne de cr√©er des op√©rations sur des ressources mettant en 
oeuvre de l'XML pour communiquer entre des applications clients / serveurs. Nous ne verrons 
pas cette technologie dans le cadre de ce cours.

### a.2.3) Autres r√¥les du backend ?
Un backend peut offrir d'autres services, comme :
- **proxy** : interm√©diaire entre les clients demandant une ressource et le serveur fournissant 
cette ressource. On verra ce type de service, notamment pour masquer l'origine d'une requ√™te √† 
une API.
- **reverse proxy** : c'est un serveur qui fait l'interm√©diaire avec d'autres serveurs, cachant 
au client qui est le v√©ritable serveur ayant trait√© de sa requ√™te. Par exemple, un proxy serveur 
peut mettre √† disposition des acc√®s √† des serveurs interne √† une entreprise (non visibles sur le web)
alors que le client interroge un serveur qui est visible sur le web.
- **serveur d'emails** ;
- ...

### a.2.3) Technologies backend possibles

Voici un exemple de technologies qui pourrait √™tre mises en oeuvre pour d√©velopper une application
backend :

<ScrollableImage name="techno.png" minWidth="586px" maxWidth="586px" />

  <figcaption>Technologies backend possibles</figcaption>

### a.2.4) Technologies backend s√©lectionn√©es pour ce cours

Voici les technologies qui ont √©t√© choisies pour √™tre mises en oeuvre 
pour d√©velopper une application backend en JS :

<ScrollableImage name="techno-course.png" minWidth="721px" maxWidth="721px" />

  <figcaption>Technologies backend en JS choisies pour ce cours</figcaption>

Nous allons utiliser Express comme framework pour rapidement d√©velopper des applications Node.js.

# <a id="b"></a>b) Introduction √† Node.js
## <a id="b1"></a> b.1) Introduction
Node.js est un environnement serveur open source permettant la cr√©ation d'outils 
et applications c√¥t√© serveur en JS.  
Node.js offre une utilisation optimale des ressources des serveurs sans d√©pendance 
√† un serveur http externe, tout en √©tant multiplateforme (Windows, Linux, Mac‚Ä¶).

Pour le d√©veloppement d'IHM de fa√ßon modernes, vous avez d√©j√† install√© l'environnement
Node.js. Mais si √ßa n'est pas install√©, il est important que vous installiez l'environnement 
[Node.js en version LTS](https://nodejs.org/en/) [[R.34]](/references/#r34).

Vous ne devez pas apprendre un nouveau langage pour d√©velopper des applications backend, 
Node.js, c'est du JS.  
Si vous avez besoin d'un rappel du langage, vous pouvez le faire ici : [Introduction au langage JS](/intro/#e).

Tr√®s souvent, Node.js est cod√© en JS conforme au standard CommonJS.
La gestion des modules est diff√©rente du JS conforme au standard ECMAScript, telle que nous avons
appris pour du JS c√¥t√© browser.

M√™me s'il est possible d'√©crire du Node.js conforme au standard ECMAScript, la majorit√© du code 
que vous trouverez sur le web sera conforme √† CommonJS.

D√®s lors, nous allons vous expliquer plus tard comment g√©rer des modules en Node.js conforme au 
standard CommonJS.

## <a id="b2"></a> b.2) Ou mettre du code Node.js ?
### b.2.1) Directement dans un terminal
Il est possible d'√©crire du code Node.js directement dans un terminal.

Pour rappel, nous vous conseillons d'utiliser Git Bash comme terminal au sein de VS Code. 

Vous devriez d√©j√† avoir configur√© VS Code pour avoir comme Terminal par d√©faut 
Git Bash. Si √ßa n'est pas fait, nous vous rappelons la proc√©dure :
- Vous devez avoir install√© Git sur votre machine.
- Clicquez √† droite du **+** au sein d'un terminal ouvert dans VS Code, 
clic sur **Select Default Profile**, puis s√©lectionnez "Git Bash".
Tous les prochains terminaux que vous ouvrirez le seront sous Git Bash, nettement plus color√© 
et int√©ressant que les autres terminaux üòé.

<ScrollableImage name="terminal-2.png" minWidth="933px" maxWidth="933px" />

<figcaption>Choix du terminal par d√©faut</figcaption>

Veuillez tester du code Node.js directement dans un terminal en tapant 
cela au sein d'un terminal de VS Code :

```bash
node
```

Vous avez maintenant acc√®s au terminal de Node.js.  
Vous pouvez tenter une op√©ration math√©matique de votre choix, comme par exemple :
**2 * Math.PI**

Incroyable mais vrai, vous avez maintenant acc√®s √† une nouvelle calculatrice sur tous les appareils 
o√π vous avez Node.js install√©. Et si Node.js n'est pas install√©, pas de panique, 
la console de votre Browser pourra toujours vous aider üòâ.

Quand vous souhaitez sortir de l'interpr√©teur de commandes de Nodes, il faut taper :
- soit deux fois **`CTRL c`**
- soit **`CTRL d`**

### b.2.2) Dans un script
Nous √©crivons g√©n√©ralement le code Node.js au sein d'un script externe.

Dans votre repo **web2**, veuillez cr√©er un r√©pertoire **/tutorials/node-start** et y 
ajouter le fichier **start.js** contenant ce code-ci :

```js
class Car {
  constructor(brand, model) {
    this.brand = brand;
    this.model = model;
    this.id = Math.random();
  }

  getDescription() {
    return `Car's description : ${this.brand}, ${this.model} , ID:${this.id}`;
  }
}

const dacia = new Car('Dacia', 'Sandero');

console.log( dacia.getDescription() );
```

Pour lancer une application Node.js, il suffit de taper dans un terminal : **`node nomScript`** 
(**`.js`** est optionnel).

Donc pour lancer le script cr√©√© ci-dessus, veuillez ouvrir un terminal au bon endroit.  
Pour rappel, Il est possible de faire un clic droit dans l'Explorer de VS Code 
sur le r√©pertoire **node-start**, **Open in Integrated Terminal** pour ouvrir un terminal 
√† l'endroit souhait√©.

Il ne vous reste plus qu'√† taper :

```bash
node start # or node start.js
```

Voila, c'est une simple application Node.js qui affiche un message dans le terminal.

## <a id="b3"></a> b.3) Les modules CommonJS
### b.3.1) Introduction
Un module est une librairie JS fournissant des objets.
Comme en JS tout est objet, un module met donc √† disposition des fonctions, des constantes, des variables...

### b.3.2) Cr√©ation d'un module
Pour cr√©er un module, il suffit de cr√©er un script JS **nomModule.js** et d'exporter des
objets au sein de ce module via **module.exports** ou **exports**.

### b.3.3) Exporter des objets
#### b.3.3.1) Introduction
Il existe plusieurs fa√ßons d'exporter des objets, soit √† la vol√©e, soit √† la fin d'un script.

üëç Nous vous recommandons de faire vos exports √† la fin du script, cela rend les scripts plus 
lisibles. 

Nous allons n√©anmoins voir toutes les fa√ßons d'exporter des objets en CommonJS, car vous trouverez
de tout sur le web.

On exporte toujours un seul objet principal dans un module. Cet objet peut bien s√ªr contenir 
une multitude d'objets via ses propri√©t√©s.

#### b.3.3.2) Export √† la fin d'un script
C'est la fa√ßon la plus propre d'exporter un seul objet :

```js
module.exports¬†=¬†router;
```

C'est l'√©quivalent d'un "default export" tel que vu en ECMAScript.

S'il y a plusieurs objets √† exporter, voici la fa√ßon recommand√©e de le faire : 

```js
module.exports¬†=¬†{authorize,¬†users¬†};
```

C'est l'√©quivalent d'un "Named export" tel que vu en ECMAScript.

#### b.3.3.3) Export √† la vol√©e

Il est possible de faire des exports √† la vol√©e, c'est √† dire d'exporter des objets 
au fur et √† mesure qu'ils sont initialis√©s.

Voici la version longue :

```js
module.exports.authorize¬†=¬†authorize;
module.exports.users¬†=¬†users¬†;
```

Il est aussi possible d'√©courter une export √† la vol√©e : 
```js
exports.authorize¬†=¬†authorize;
exports.users¬†=¬†users¬†;
```

Voici quelques pr√©cisions :
- **`module.exports`** : c'est la r√©f√©rence de l'objet retourn√©e par l'appel de **`required()`** 
(m√©thode qui sera utilis√©e pour l'import).
- **`exports`** : c'est la r√©f√©rence vers **`module.exports`**, **`exports`** 
n'est pas retourn√© par l'appel de **`required()`**.

‚ö° Il faut faire attention au mauvais usage de l'utilisation de **`exports`**. 
Voici une mauvaise utilisation :

```js
exports¬†=¬†{¬†authorize,¬†users¬†};¬†/*¬†exports¬†has¬†a¬†new¬†reference,¬†
                                   it¬†is¬†no¬†longer¬†linked¬†to¬†module.exports */
```

### b.3.4) Importer des objets
#### b.3.4.1) Introduction
Pour utiliser des objets (fonctions, constantes, objets, classes...) au sein d'un script JS 
provenant de modules, on le fait √† l'aide de la fonction **`required()`** et du 
chemin vers le module √† utiliser.

Il est possible d'importer tant des objets de modules que l'on a cr√©√© soi-m√™me, 
que de packages mis √† disposition via un gestionnaire de packages.

#### b.3.4.2) Import d'un module
Lorsqu'un seul objet a √©t√© export√©, on l'importe en lui donnant le nom que l'on souhaite 
√† l'import et en indiquant le chemin vers le module √† utiliser.

```js
const¬†pizzaRouter¬†=¬†require('./routes/pizzas');
```

Lorsque plusieurs objets ont √©t√© export√©s, on importe ce que l'on souhaite en utilisant 
des accolades et en indiquant le chemin vers le module √† utiliser.

```js
const¬†{¬†users,¬†authorize¬†}¬†=¬†require('../utils/auths');
```

#### b.3.4.2) Import d'un package
Il est aussi possible d'importer des objets de packages offerts par la 
communaut√© via votre gestionnaire de package.
Pour ce faire, il est juste n√©cessaire d'indiquer le nom du package lors de l'import.

Si un seul objet est export√© par un package, voici un exemple de comment le r√©cup√©rer :

```js
//¬†module¬†integrated¬†to¬†the¬†runtime¬†environment
const¬†http¬†=¬†require('http');
//¬†module¬†following package installation
const¬†shortid¬†=¬†require('shortid');
```

## <a id="b4"></a> b.4) Introduction aux packages
### b.4.1) Introduction
Dans le cadre du d√©veloppement d'IHM modernes, au module 2, nous avons d√©couvert le gestionnaire 
de packages de Node.js. Nous allons r√©sumer les concepts importants ci-dessous.

### b.4.2) Gestionnaire de packages
**npm** est le gestionnaire de packages de Node.js. 

On peut faire des recherches de packages qui serait utiles √† nos application web 
sur [npmjs.com](https://www.npmjs.com/) [[R.48]](/references/#r48).

### b.4.3) Fichier de configuration d'un projet
Tous les packages associ√©s √† une app, ses d√©pendances, sont donn√©es dans le fichier :
**package.json**.

C'est le fichier qui d√©crit la configuration d'un projet JS.

On peut manuellement cr√©er ce fichier √† l'aide de la commande **`npm init`** 
si l'on souhaite quelque chose de plus interactif
ou **`npm init -y`** si l'on souhaite un fichier avec le minimum autog√©n√©r√©.

Voici un exemple de fichier **package.json** :

```json
{
  "name": "api2",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },
  "nodemonConfig": {
    "ignore": [
      "data/*"
    ],
    "exec": "npm run lint && node"
  },
  "dependencies": {
    "cookie-parser": "~1.4.4",
    "debug": "~2.6.9",
    "express": "~4.16.1",
    "morgan": "~1.9.1"
  },
  "devDependencies": {
    "eslint": "^8.19.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "nodemon": "^2.0.19",
    "prettier-airbnb-config": "^1.0.0"
  },
  "author": "e-Baron"
}
```

Lors de l'installation d'un package, 
celui-ci s'ajoute √† la liste des d√©pendances.  
Ainsi, si des d√©veloppeurs trouvent votre projet sur Git,
ils n'auront qu'√† ex√©cuter **`npm i`** afin d'installer toutes les d√©pendances.

C'est dans le r√©pertoire **node_modules** que toutes les d√©pendances seront install√©es. 
Ces d√©pendances peuvent √™tre tr√®s volumineuses. C'est donc important de ne jamais 
mettre ce dossier sur vos web repository, via Git.  
Pour ce faire, n'oubliez pas d'inclure un fichier **.gitignore** dans vos repos 
pour ignore **node_modules**.

**package.json** indique les scripts de d√©marrage, 
en fonction de la fa√ßon dont nous souhaitons d√©marrer l'application.

```json
  "scripts": {
    "debug": "npm run dev",
    "dev": "nodemon ./bin/www",
    "start": "node ./bin/www",
    "lint": "eslint **/*.js",
    "lint:fix": "npm run lint -- --fix"
  },  
```

Au regard de cette configuration, on peut d√©marrer l'application √† l'aide de **`npm start`**
ou **`npm run start`**, 
ce qui ex√©cutera le script **`./bin/www`** √† l'aide de **node**.  
On pourrait aussi d√©marer l'application √† l'aide de **`npm run dev`**, ce qui d√©marrerait l'application 
√† l'aide de **nodemon**, un outil permettant de monitorer les changements de fichiers et de 
red√©marrer automatiquement le serveur en cas de changement.

NB : nous verrons plus tard cet outil **nodemon** pour simplifier le d√©veloppement.

### b.4.4) Installer un package
Pour installer un package (ou une d√©pendance), 
il suffit de faire : **`npm i nomDuPackage`** ou **`npm install nomDuPackage`**.

### b.4.5) D√©pendances install√©es
On a vu que **`npm i`** permet d'installer toutes les d√©pendances se trouvant dans 
**package.json**, ainsi que toutes les d√©pendances de ces d√©pendances...

L'arbre exact des d√©pendances install√©es, num√©ro de version..., se trouve dans 
**package-lock.json**. Ce fichier est g√©n√©r√© automatiquement pour chaque op√©ration
modifiant **node_modules** ou **package.json**.

‚ö° Si un fichier **package-lock.json** est compris dans un repo, lorsque vous introduirez 
**`npm i`** pour installer toutes les d√©pendances, npm installera les m√™mes versions que celles 
se trouvant dans **package-lock.json**. Cela peut poser des probl√®mes si votre environnement 
Node.js est en version diff√©rente. En cas de souci, pensez √† effacer le r√©pertoire **node_modules** 
et le fichier **package-lock.json** avant de relancer l'installation de toutes les d√©pendances.

### b.4.6) Localisation d'un module ou package par Node
Node va chercher dans tous les chemins sp√©cifi√©s dans **module.paths** : **node_modules**, **.**...
lorsque **`required()`** est appel√©.

### b.4.7) Mise √† jour des packages vers leur derni√®re version
La mise √† jour de toutes les d√©pendances peut parfois amener √† des gros soucis.

Vous pouvez tenter de mettre √† jour tous vos package en suivant la documentation de Node.js :
[Update all the Node.js dependencies to their latest version](https://nodejs.dev/learn/update-all-the-nodejs-dependencies-to-their-latest-version)
[[R.49]](/references/#r49)

Mais attention, certains packages parfois subissent des "breaking changes", 
ce qui impose que vous deviez faire migrer votre code avant que celui-ci soit fonctionnel.

Nous vous recommandons donc, si vous rencontrer un probl√®me lors de la mise √† jour de tous vos 
packages d'un coup, de revenir √† la situation initiale, et de faire l'upgrade de chaque 
package list√© dans **package.json** individuellement.

# <a id="c"></a> c) Introduction √† Express
## <a id="c1"></a>  c.1) Introduction
Voici le moto du framework Express: "Fast, unopinionated, minimalist web framework for Node.js" 
[Express](https://expressjs.com/)
[[R.50]](/references/#r50).

Express est un framework qui permet de rapidement cr√©er des applications en Node.js. 

Il est possible de cr√©er une application Express soit "from scratch", soit √† partir 
d'un boilerplate.

Dans le cadre de ce cours, nous allons plut√¥t utiliser des boilerplates 
pour g√©n√©rer des applications. N√©anmoins, il est int√©ressant de voir comment cr√©er 
une application "from scratch".

## <a id="c2"></a> c.2) Cr√©er une application Express "from scratch"
Il faut d'abord cr√©er un r√©pertoire pour votre application.

Au sein de votre repo **web2**, veuillez cr√©er le r√©pertoire **/tutorials/express-static-file-server**.

Veuillez, via le terminal, entrer dans ce r√©pertoire.

Pour la suite du tutoriel, nous consid√©rons que tous les chemins absolus d√©marrent du r√©pertoire
**/tuturials/express-static-file-server**.

Dans ce r√©pertoire, veuillez g√©n√©rer le fichier de configuration du projet (**package.json**) :
**`npm init`**.  
Veuillez r√©pondre aux questions pour configurer le point d'entr√©e de l'application comme √©tant 
le script **index.js**.

Veuillez configurer le script de d√©marrage de votre application en ajoutant cette ligne au sein 
de **package.json** :

```json {2}
  "scripts": {
    "start": "node index.js",
```

Ainsi, notre application pourra d√©marrer √† l'aide de la commande **`npm start`**.

A ce stade-ci, voila √† quoi devrait ressembler votre **package.json** :

```json
{
  "name": "express-static-file-server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "yourName",
  "license": "ISC"
}
```

Veuillez installer Express, son package : 

```bash
npm i express
```

Nous allons cr√©er un simple serveur de fichiers statiques √† l'aide du 
middleware **express.static**, afin de servir tous les fichiers qui se trouveront dans 
le r√©pertoire **public**.

Tout d'abord, t√©l√©chargez ce zip : <LinkFile name="public.zip" target="_blank" download>fichiers statiques</LinkFile>.

Veuillez d√©sarchiver ce r√©pertoire dans votre projet afin d'avoir les fichiers statiques 
qui seront partag√©s par votre serveur au sein de **/public**.  
V√©rifiez bien que vous n'avez qu'un seul r√©pertoire **/public** et pas un **/public/public**.

Il ne reste plus qu'√† cr√©er le serveur. Veuillez cr√©er le fichier **/index.js** et y ajouter 
ce code :

```js
const express = require('express');
const app = express();

app.use(express.static('public'));

const PORT = 7777;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

On voit que juste cette ligne permet la mise en place d'un serveur de fichier statique, 
via le middleware **express.static** :

```js
app.use(express.static('public'));
```

Et pour d√©marrer un serveur web qui √©coute sur le port **7777**, ces lignes sont suffisantes :
```js
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

Veuillez lancer l'application en tapant cela dans votre terminal au sein du r√©pertoire du projet :

```bash
npm start
```

Pour acc√©der au serveur de fichiers, vous pouvez le faire via un browser : 
[http://localhost:7777](http://localhost:7777)

Si tout se passe bien, vous devriez avoir acc√®s au site de la pizzeria d√©velopp√© au module 1 de 
ce cours.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message
"**express-static-file-server**".

En cas de souci, vous pouvez acc√©der au code de cette d√©mo ici :
[express-static-file-server](https://github.com/e-vinci/js-demos/tree/main/backend-restful-api/express-static-file-server/).

## <a id="c3"></a> c.3) Cr√©er une application Express via un g√©n√©rateur
Le g√©n√©rateur d'applications **express-generator** permet de g√©n√©rer le boilerplate 
d'une application Express de base.

A l'aide du g√©n√©rateur d'applications Express, vous allez cr√©er une application Express 
sans "view engine" car nous n'allons pas faire du Server Side Rendering 
dans le cadre de ce cours.

Veuillez ouvrir un terminal au sein de VS Code au niveau du r√©pertoire **/tutorials**.

Ensuite, cr√©ez une application nomm√©e **basic-generated-app** en tapant :

```bash
npx express-generator --no-view basic-generated-app
```

**npx** permet de directement ex√©cuter un package en mode de commandes en installant une copie 
locale et temporaire de ce package (et de ses d√©pendances).

Veuillez installer les d√©pendances de votre app et la d√©marrer :

```bash
cd basic-generated-app
npm i 
npm start
```

Si vous copier / coller le contenu du r√©pertoire **/public** du tutoriel pr√©c√©dent 
dans le r√©pertoire **public** g√©n√©r√©, l'application fournira le m√™me r√©sultat que la pr√©c√©dente, 
mais sur un port diff√©rent : [http://localhost:3000](http://localhost:3000).

Nous allons d√©couvrir en d√©tails ce qui a √©t√© g√©n√©r√© par **express-generator** un peu plus tard.

Actuellement, on remarquera : 
- le point d'entr√©e de l'application est **./bin/www** au regard de **package.json**;
- que **./bin/www** d√©marre un serveur web sur le port **3000** en lui demandant de s'occuper 
de d√©marrer tous les middlewares en lui passant tout ce qui est export√© de **app.js**.
- **app.js** met aussi √† disposition un serveur de fichier statiques servant le contenu du r√©pertoire 
**public**.

Avant d'aller dans les d√©tails d'Express que nous souhaitons utiliser pour d√©velopper des 
services web de type RESTful, nous allons voir ce que nous entendons par RESTful.

# <a id="d"></a> d) Introduction aux RESTful API
## <a id="d1"></a> d.1) Introduction
**REST** vient de **RE**presentational **S**tate **T**ransfer : c'est un 
style architectural pour construire des applications web extensibles, o√π les client et serveurs
sont s√©par√©s.

Dans une application REST, une **interface uniforme** (ou API) est d√©finie afin de permettre √† des 
applications de coop√©rer.

Toute application REST se doit d'√™tre **stateless** : il n'y a pas d'enregistrement du contexte 
d'une session sur le serveur pour comprendre une requ√™te d'un client.  
Ainsi, les requ√™tes clientes ne d√©pendent pas d'un historique de requ√™tes, elles sont autoportantes.

Une RESTful API met √† disposition des **op√©rations** sur des **ressources** via :
- des **URI** ; il y a donc une adresse unique pur chaque ressource ;
- des **m√©thodes HTTP** (GET, POST, DELETE, PUT) repr√©sentant les op√©rations possibles (CRUD, op√©rations de type Create, Read, 
Update ou Delete) ;
- des **repr√©sentations** des ressources compr√©hensibles tant par les clients que les serveurs ; 
les ressources sont repr√©sent√©es par leur "Media type" : **JSON**, **XML**, **HTML**, **TXT**, **JPEG**... ;
dans le cadre de ce cours, les ressources seront quasi toujours repr√©sent√©es via du **JSON**.

## <a id="d2"></a> d.2) Conventions REST

 Le type d'op√©ration CRUD (Create, Read, Update ou Delete) sur une ressource est d√©fini 
 via la m√©thode http de la requ√™te.  
 Les op√©rations possibles sont :
  - GET = Read
  - POST = Create
  - DELETE = Delete üòâ
  - PUT (ou PATCH) = Update

Voici un exemple d'application de ces conventions REST dans le cadre d'une RESTful API 
permettant de g√©rer des films :

| URI | M√©thode HTTP | Op√©ration |
|---|---|---|
| **films** | GET | READ ALL : Lire toutes les ressources de la collection |
| **films?minimum-duration=value** | GET | READ ALL FILTERED : Lire toutes les ressources de la collection selon le filtre donn√© |
| **films/{id}** | GET | READ ONE : Lire la ressource identifi√©e |
| **films** | POST | CREATE ONE : Cr√©er une ressource bas√©e sur les donn√©es de la requ√™te |
| **films/{id}** | DELETE | DELETE ONE : Effacer la ressource identifi√©e |
| **films/{id}** | PUT | UPDATE ONE : Replacer l'enti√®ret√© de la ressource par les donn√©es de la requ√™te |

Si cette API est h√©berg√©e √† l'URL racine **http://ilovemoovies.org**, alors nous pourrions identifier 
une ressource de type **films** de cette fa√ßons : **http://ilovemoovies.org/films/10**.

Pour lire cette ressource, il faudrait faire une requ√™te http de type **GET** sur cette **URL** : 
**http://ilovemoovies.org/films/10**.

# <a id="e"></a> d) RESTful API via Express
## <a id="e1"></a> e.1) Introduction
Nous avons pr√©c√©demment g√©n√©r√© une application Express √† l'aide du g√©n√©rateur d'applications.

Veuillez avoir devant vous le code de cette application car nous allons d√©couvrir le r√¥le des 
r√©pertoires et fichiers importants g√©n√©r√©s par **express-generator**.

Nous allons maintenant nous attarder √† comprendre les concepts associ√©s √† l'utilisation d'Express,
mais en focalisant sur ceux utiles aux applications REST.

Voici comment une requ√™te faite √† une application Express est trait√©e :

<ScrollableImage name="express-flow.png" minWidth="800px" maxWidth="800px" />

<figcaption>Flux d'une requ√™te vers une application Express [R.51]</figcaption>

Dans ce flux de traitement d'une requ√™te, c'est la seule responsabilit√© du d√©velopeur est de 
s'occuper de la partie "Middleware".

La grande majorit√© du code √©crit sera du "routing middleware" : notre code s'occupera de r√©pondre
√† des requ√™tes clientes pour diff√©rentes URLs et m√©thodes HTTP (GET, POST...).

## <a id="e2"></a> e.2) Configuration et d√©marrage d'une application Express
On l'a d√©j√† vu, la configuration d'une application Express, comme toutes applications Node.js, 
est faite au sein de **package.json**.

En fonction de comment est configur√© l'application, on la d√©marrera via **npm start**, 
**npm run dev**...

## <a id="e3"></a> e.3) Serveur web int√©gr√©
Un serveur web int√©gr√© √† nos applications Express est d√©marr√© au sein du fichier **bin/www**.

C'est ce fichier que vous devez mettre √† jour si par exemple vous souhaitez que votre application 
fonctionne sur un port diff√©rent que le port par d√©faut **3000**.

Un serveur int√©gr√© est diff√©rent d'une application web offerte par un serveur standalone comme 
Apache, Tomcat... C'est un serveur tr√®s l√©ger d√©di√© √† votre application.

## <a id="e4"></a> e.4) Les middlewares Express

Les middlewares s'occupe du traitement des requ√™tes des clients et de la pr√©paration des r√©ponses :

<ScrollableImage name="middlewares.jpg" minWidth="638px" maxWidth="638px" />

<figcaption>Les fonctions Middleware et Express [R.52]</figcaption>