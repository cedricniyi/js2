---
title: "UI dynmamique"
description: "Cr√©ation dynamique de UI"
---

<PathViewer>
    <PathViewerItem to="/"> web2course </PathViewerItem>
    <PathViewerItem to="/part2"> Partie 2 </PathViewerItem>
    <PathViewerItem selected> e) Cr√©ation dynamique de UI </PathViewerItem>
</PathViewer>

# e) Cr√©ation dynamique de UI

<InternalPageMenu>
  <InternalPageMenuItem> Pourquoi g√©n√©rer dynamiquement une UI ? </InternalPageMenuItem>
  <InternalPageMenuItem> G√©n√©ration d'HTML √† partir d'une string </InternalPageMenuItem>
  <InternalPageMenuItem> Le layout en Bootstrap  </InternalPageMenuItem>
  <InternalPageMenuItem> Les breakpoints en Bootstrap </InternalPageMenuItem>
  <InternalPageMenuItem> Les composants Bootstrap </InternalPageMenuItem>
  <InternalPageMenuItem> Utilisation de Bootstrap avec Webpack </InternalPageMenuItem>
</InternalPageMenu>


- c) [D√©veloppement d'IHM dynamiques](#c)
  - c.1) [Introduction](#c1)
  - c.2) [G√©n√©ration d'HTML √† partir d'une string](#c2)
  - c.3) [Ajout dynamique d'√©couteurs d'√©v√©nements une fois le DOM rendu](#c3)
  - c.4) [G√©n√©ration d'HTML √† partir de Nodes](#c4)
  - c.5) [Ajout dynamique d'√©couteurs d'√©v√©nements avant de rendre le DOM](#c5)
  - c.6) [Utilisation de Bootstrap dans un frontend moderne](#c6)
- d) [Debbuging d'un frontend tournant sous Webpack](#d)
- e) [Exercice 2.1 : Homepage statique de myMovies & Webpack](#e)
- f) [Exercice 2.2 : G√©n√©ration dynamique de la Homepage de myMovies](#f)
- g) [Exercice 2.3 : G√©n√©ration dynamique d'une table sur base d'un formulaire](#g)
- h) [üç¨ Exercice 2.4 : design responsive](#g)


# <InternalPageTitle> Pourquoi g√©n√©rer dynamiquement une UI ? </InternalPageTitle>

Nous souhaitons parfois g√©n√©rer des parties d'IHM dynamiquement, √† l'aide de JS.

Nous pourrions souhaiter g√©n√©rer de l'HMTL dynamiquement pour plusieurs raisons. Par exemple, si nous souhaitions afficher diff√©rentes pages sans faire appel au serveur.
Lors d'un clic sur un √©l√©ment d'une Navbar, nous pourrions g√©n√©rer dynamiquement l'HTML de la page associ√©e √† cet √©l√©ment.

Un autre exemple serait l'affichage d'un tableau HTML suite √† la r√©ception de donn√©es envoy√©es par un web service.

Il existe principalement deux fa√ßon de g√©n√©rer des √©l√©ments HTML, soit √† partir de String, soit √† partir de "Nodes" (ou HTML elements).

# <InternalPageTitle> G√©n√©ration d'HTML √† partir d'une string </InternalPageTitle>

Nous pouvons utiliser la propri√©t√© **innerHTML** d'un √©l√©ment existant pour cr√©er de l'HTML √† l'aide d'une String.

Lorsque nous allons ajouter une String √† la propri√©t√© **innerHTML** d'un √©l√©ment, le browser va s'occuper de cr√©er des "Node elements" et les attacher au "DOM tree" au sein de l'√©l√©ment que nous modifions. 

Nous souhaitons ajouter un menu √† notre site de la pizzeria √† g√©n√©rer √† partir d'un array.

Voici le nouveau code √† ajouter pour g√©n√©rer ce menu au sein de **/src/index.js** : 


```js numbered {5-31,37,46-86}
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

const body = document.querySelector('body');

body.addEventListener('click', startOrStopSound);

renderMenuFromString(MENU);

function startOrStopSound() {
  const myAudioPlayer = document.querySelector('#audioPlayer');

  if (myAudioPlayer.paused) myAudioPlayer.play();
  else myAudioPlayer.pause();
}

function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  main.innerHTML += menuTableAsString;
}

function getMenuTableAsString(menu) {
  const menuTableLines = getAllTableLinesAsString(menu);
  const menuTable = addLinesToTableHeadersAndGet(menuTableLines);
  return menuTable;
}

function addLinesToTableHeadersAndGet(tableLines) {
  const menuTable = `
  <div class="table-responsive pt-5">
    <table class="table table-danger">
      <tr>
        <th>Pizza</th>
        <th>Description</th>
      </tr>
      ${tableLines}    
    </table>
  </div>
  `;
  return menuTable;
}

function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}
```

Dans un premier temps, nous avons acc√©der √† l'√©l√©ment **main** en tant qu'HTML element (ou Node).

Nous avons ensuite g√©n√©r√© une String multilignes √† l'aide des `template literals` pour repr√©senter le menu, pour finalement ajouter au **main** de nouveaux √©l√©ments en concat√©nant cette String √† sa propri√©t√© **innerHTML**. 

# <InternalPageTitle> Ajout dynamique d'√©couteurs d'√©v√©nements une fois le DOM rendu </InternalPageTitle>

A ce stade-ci, nous souhaiterions ajouter un gestionnaire de passage de souris sur le menu.  
Au passage sur le menu, nous souhaitons changer la couleur du background afin que le menu devienne vert. Lorsqu'on quitte le menu, celle-ci doit reprendre sa couleur initiale.

Voici le code mis √† jour de **index.js** :

```js numbered {39,90-99}
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

const body = document.querySelector('body');

body.addEventListener('click', startOrStopSound);

renderMenuFromString(MENU);

attachOnMouseEventsToGoGreen();

function startOrStopSound() {
  const myAudioPlayer = document.querySelector('#audioPlayer');

  if (myAudioPlayer.paused) myAudioPlayer.play();
  else myAudioPlayer.pause();
}

function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  main.innerHTML += menuTableAsString;
}

function getMenuTableAsString(menu) {
  const menuTableLines = getAllTableLinesAsString(menu);
  const menuTable = addLinesToTableHeadersAndGet(menuTableLines);
  return menuTable;
}

function addLinesToTableHeadersAndGet(tableLines) {
  const menuTable = `
  <div class="table-responsive pt-5">
    <table class="table table-danger">
      <tr>
        <th>Pizza</th>
        <th>Description</th>
      </tr>
      ${tableLines}    
    </table>
  </div>
  `;
  return menuTable;
}

function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}

function attachOnMouseEventsToGoGreen() {
  const table = document.querySelector('table');
  table.addEventListener('mouseover', () => {
    table.className = 'table table-success';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-danger';
  });
}
```

Une fois le menu rendu, nous y acc√©dons en obtenant une r√©f√©rence vers le Node repr√©sentant ce menu au sein du DOM tree.

Nous acc√©dons √† l'attribut **class** d'une **table** en modifiant, en JS, l'attribut **className**.  
Il est aussi possible d'affiner la gestion des classes CSS en ajoutant ou supprimant des classes via la propri√©t√© **classList** d'un Node (ou HTML element).

Ici, nous avons utilis√© les classes Bootstrap "table-success" pour mettre en vert, et "table-danger" pour que √ßa soit en rouge.

Il est √† noter ces dangers quand on utilise des Strings pour g√©n√©rer de l'HTML.

## ‚ö° Danger N¬∞1 : oubli de mettre √† jour le DOM avant d'attacher ses √©couteurs

Il arrive tr√®s souvent aux jeunes d√©veloppeurs web de faire une erreur de ce genre.  
Regarder le code d'**index.js** et imaginez que vous attachiez les √©couteurs d'√©v√©nements dans **renderMenuFromString()** et plus apr√®s l'appel de cette fonction :

```js {6}
function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  attachOnMouseEventsToGoGreen();

  main.innerHTML += menuTableAsString;
}
```

Comme la **table** n'a pas √©t√© rendue dans le DOM, il n'est pas possible d'acc√©der √† celle-ci !  
Une exception serait donc lanc√©e dans la console de votre browser.

Tout cela semble logique, mais pensez-y en cas de souci avec vos √©couteurs d'√©v√©nements üòâ.

## ‚ö° Danger N¬∞2 : mise √† jour du DOM apr√®s avoir ajout√© ses √©couteurs

Il arrive aussi r√©guli√®rement aux jeunes d√©veloppeurs web de faire une erreur de ce style.  
Regardez le code d'**index.js** et imaginez que vous souhaitiez ajouter une l√©gende au menu :

```js {5-6}
renderMenuFromString(MENU);

attachOnMouseEventsToGoGreen();

const mainWrapper = document.querySelector('main');
mainWrapper.innerHTML += '<figcaption class="text-light text-decoration-underline">Our pizzas</figcaption>';
```

‚ö° L'update du DOM d'un √©l√©ment fait un reset de tous les √©couteurs d'√©v√©nements pr√©c√©demment attach√©s ! Pensez-y en cas de souci avec vos √©couteurs d'√©v√©nements üòâ.  
Dans notre exemple, la gestion des passages de la souris sur le menu des pizzas ne serait plus fonctionnelle.

## <a id="c4"></a>c.4) G√©n√©ration d'HTML √† partir de Nodes
Il est possible de directement cr√©er un Node (ou HTML element) √† l'aide de la m√©thode **`document.createElement()`**.

Une fois un Node cr√©√©, on demande de l'ajouter au "DOM tree" via la m√©thode **`appendChild()`**.

Voici un petit exemple d'ajout d'un titre au **main** :

```js
const mainWrapper = document.querySelector('main');
// Create the child element
const h1 = document.createElement('h1');
// Change its property
h1.innerText = 'Hello World';
// Attach the child element to its parent
mainWrapper.appendChild(h1);
```

Nous souhaitons ajouter un nouveau menu pour les boissons √† notre site de la pizzeria, √† g√©n√©rer √† partir d'un array.

Voici le nouveau code √† ajouter pour g√©n√©rer la liste des boissons au sein de **/src/index.js** : 


```js numbered {33-49,59,121-159}
import 'bootstrap/dist/css/bootstrap.min.css';
import './stylesheets/main.css';
import 'animate.css';

const MENU = [
  {
    id: 1,
    title: '4 fromages',
    content: 'Gruy√®re, S√©rac, Appenzel, Gorgonzola, Tomates',
  },
  {
    id: 2,
    title: 'Vegan',
    content: 'Tomates, Courgettes, Oignons, Aubergines, Poivrons',
  },
  {
    id: 3,
    title: 'Vegetarian',
    content: 'Mozarella, Tomates, Oignons, Poivrons, Champignons, Olives',
  },
  {
    id: 4,
    title: 'Alpage',
    content: 'Gruy√®re, Mozarella, Lardons, Tomates',
  },
  {
    id: 5,
    title: 'Diable',
    content: 'Tomates, Mozarella, Chorizo piquant, Jalapenos',
  },
];

const DRINKS = [
  {
    id: 1,
    title: 'Lemonade',
    content: 'Sparkling water, lemon, ice cubes',
  },
  {
    id: 2,
    title: 'Ice tea',
    content: 'Mint, ginger, water',
  },
  {
    id: 3,
    title: 'Exotic Kombucha',
    content: 'Mango, Sparkling water, Fermented tea',
  },
];

const body = document.querySelector('body');

body.addEventListener('click', startOrStopSound);

renderMenuFromString(MENU);

attachOnMouseEventsToGoGreen();

renderDrinksFromNodes(DRINKS);

function startOrStopSound() {
  const myAudioPlayer = document.querySelector('#audioPlayer');

  if (myAudioPlayer.paused) myAudioPlayer.play();
  else myAudioPlayer.pause();
}

function renderMenuFromString(menu) {
  const menuTableAsString = getMenuTableAsString(menu);

  const main = document.querySelector('main');

  main.innerHTML += menuTableAsString;
}

function getMenuTableAsString(menu) {
  const menuTableLines = getAllTableLinesAsString(menu);
  const menuTable = addLinesToTableHeadersAndGet(menuTableLines);
  return menuTable;
}

function addLinesToTableHeadersAndGet(tableLines) {
  const menuTable = `
  <div class="table-responsive pt-5">
    <table class="table table-danger">
      <tr>
        <th>Pizza</th>
        <th>Description</th>
      </tr>
      ${tableLines}    
    </table>
  </div>
  `;
  return menuTable;
}

function getAllTableLinesAsString(menu) {
  let pizzaTableLines = '';

  menu?.forEach((pizza) => {
    pizzaTableLines += `<tr>
      <td>${pizza.title}</td>
      <td>${pizza.content}</td>
    </tr>`;
  });

  return pizzaTableLines;
}

function attachOnMouseEventsToGoGreen() {
  const table = document.querySelector('table');
  table.addEventListener('mouseover', () => {
    table.className = 'table table-success';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-danger';
  });
}

function renderDrinksFromNodes(drinks) {
  const drinksTableAsNode = getDrinksTableAsNode(drinks);

  const main = document.querySelector('main');

  main.appendChild(drinksTableAsNode);
}

function getDrinksTableAsNode(drinks) {
  const tableWrapper = document.createElement('div');
  tableWrapper.className = 'table-responsive pt-5';
  const table = document.createElement('table');
  const tbody = document.createElement('tbody');
  table.id = 'table-drinks';
  table.className = 'table table-success';
  tableWrapper.appendChild(table);
  table.appendChild(tbody);
  const header = document.createElement('tr');
  const header1 = document.createElement('th');
  header1.innerText = 'Drink';
  const header2 = document.createElement('th');
  header2.innerText = 'Description';
  header.appendChild(header1);
  header.appendChild(header2);
  tbody.appendChild(header);

  drinks?.forEach((drink) => {
    const line = document.createElement('tr');
    const title = document.createElement('td');
    const description = document.createElement('td');
    title.innerText = drink.title;
    description.innerText = drink.content;
    line.appendChild(title);
    line.appendChild(description);
    tbody.appendChild(line);
  });

  return tableWrapper;
}
```

## <a id="c5"></a>c.5) Ajout dynamique d'√©couteurs d'√©v√©nements avant de rendre le DOM
Lorsque l'on vient de cr√©er un Node, il est possible de directement lui attacher un √©couteur d'√©v√©nements.

Nous souhaiterions ajouter un gestionnaire de passage de souris sur la liste des boissons.  
Au passage sur la liste, nous souhaitons changer la couleur du background afin qu'elle devienne rouge. Lorsqu'on quitte la liste, celle-ci doit reprendre sa couleur initiale.

Voici le code que vous devez ajouter √† la m√©thode **getDrinksTableAsNode()** au sein de **index.js** :

```js numbered {30-36}
function getDrinksTableAsNode(drinks) {
  const tableWrapper = document.createElement('div');
  tableWrapper.className = 'table-responsive pt-5';
  const table = document.createElement('table');
  const tbody = document.createElement('tbody');
  table.id = 'table-drinks';
  table.className = 'table table-success';
  tableWrapper.appendChild(table);
  table.appendChild(tbody);
  const header = document.createElement('tr');
  const header1 = document.createElement('th');
  header1.innerText = 'Drink';
  const header2 = document.createElement('th');
  header2.innerText = 'Description';
  header.appendChild(header1);
  header.appendChild(header2);
  tbody.appendChild(header);

  drinks?.forEach((drink) => {
    const line = document.createElement('tr');
    const title = document.createElement('td');
    const description = document.createElement('td');
    title.innerText = drink.title;
    description.innerText = drink.content;
    line.appendChild(title);
    line.appendChild(description);
    tbody.appendChild(line);
  });

  table.addEventListener('mouseover', () => {
    table.className = 'table table-danger';
  });

  table.addEventListener('mouseout', () => {
    table.className = 'table table-success';
  });

  return tableWrapper;
}
```

Nous avons ajout√© deux √©couteurs d'√©v√©nements √† la **table** en cours de construction.  
Notons que ces √©couteurs peuvent √™tre ajout√©s avant ou apr√®s avoir fait l'ajout de la table dans le "DOM tree", cela ne change rien.

Regardez le code d'**index.js** et imaginez que vous souhaitiez ajouter une l√©gende √† la liste de boissons, en utilisant des Nodes :

```js {3-7}
renderDrinksFromNodes(DRINKS);

const mainWrapper = document.querySelector('main');
const figcaption = document.createElement('figcaption');
figcaption.innerText = 'Our drinks';
figcaption.className = 'text-light text-decoration-underline';
mainWrapper.appendChild(figcaption);
```

Le fait d'ajouter un Node au "DOM tree" ne fait pas de reset des √©couteurs d'√©v√©nements pr√©c√©demment attach√©s ! C'est un avantage √† g√©n√©rer de l'HTML √† partir de Nodes plut√¥t qu'√† partir d'une string.

N'h√©sitez pas √† tester ce morceau de code pour vous rendre compte que la liste de boissons continue √† bien g√©rer les mouvements de la souris.

## <a id="c6"></a>c.6) Ajout dynamique d'images ou d'autres assets 
Lorsque l'on souhaite ajouter une image ou tout autre assets (son, vid√©o...) via du JS et que l'on utilise un module bundler comme Webpack, on ne peut pas juste ajouter une balise **`<image`** avec le chemin en relatif vers celle-ci.

Pourquoi pas ?  Parce qu'en fait, le bundler va s'occuper de copier, et parfois d'optimiser les assets dans le "build", g√©n√©ralement g√©n√©r√© dans le r√©pertoire **/dist** de votre projet.
Ainsi, lorsque vous d√©veloppez votre code, l'image se trouve √† un endroit diff√©rent d'o√π se trouvera l'image lors du build.

Pour bien g√©rer les URL au sein de votre JS, vous devez d'abord importer vos assets.  
Voici un exemple pour ajouter une image dynamiquement au sein du **`<footer>`** : 

```js
import pizzaImage from './img/pizza2.jpg';

renderPizzaImage(pizzaImage);

function renderPizzaImage(pizzaUrl) {
  const image = new Image(); // or document.createElement('img');
  image.src = pizzaUrl;
  image.height = 50;
  const footer = document.querySelector('footer');
  footer.appendChild(image);
}
```

Le type du Asset Module configur√© dans le fichier **webpack.config.js** est **'asset/resource'**.  
Cela signifie que pour chaque fichier import√© dans le JS, il sera √©mis dans le "output directory", (ou "build directory"), g√©n√©ralement dans **/dist**, avec comme non de fichier qqch qui ressemble √† un hash (par exemple 151cfcfa1bd74779aadb.png) et leur chemins (paths) seront inject√© dans le bundle.

Dans l'exemple, le chemin de l'image **pizza2.png** lors de l'ex√©cution de l'application sera donn√© dans la variable **pizzaImage**.

Veuillez mettre √† jour votre site de la pizzeria pour afficher cette image dans le footer : <LinkFile name="pizza2.jpg" target="_blank" download>Pizza √† ajouter dans le footer [R.38]</LinkFile>.

Si tout fonctionne bien, faites un **commit** de votre repo (**web2**) avec le message "**modern-dynamic-hmi**".

En cas de souci, vous pouvez acc√©der au code de cette √©tape du tutoriel ici : [modern-dynamic-hmi](https://github.com/e-vinci/js-demos/tree/main/frontend/frontend-essentials/modern-dynamic-hmi).

Si vous souhaitez plus d'informations sur la gestion des assets via Webpack, vous pouvez le faire via les [Asset Modules](https://webpack.js.org/guides/asset-modules/) [[R.37]](/references/#r37).